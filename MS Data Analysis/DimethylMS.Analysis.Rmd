---
title: "Dimethyl MS Data"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Preparatory code - Packages

###Load necessary packages to use on your data. 
For data manipulation:
```{r cars, message=FALSE}
library(dplyr)
```
For gene list annotation:
```{r message=FALSE}
library("AnnotationDbi")
```

For mouse (Mm) database information from entrez gene (eg). Keys that you can use with this data are listed below, which you will want to know for later as you use functions from the AnnotationDbi packages 

[1] "ACCNUM"       "ALIAS"        "ENSEMBL"      "ENSEMBLPROT" 
[5] "ENSEMBLTRANS" "ENTREZID"     "ENZYME"       "EVIDENCE"    
[9] "EVIDENCEALL"  "GENENAME"     "GO"           "GOALL"       
[13] "IPI"          "MAP"          "OMIM"         "ONTOLOGY"    
[17] "ONTOLOGYALL"  "PATH"         "PFAM"         "PMID"        
[21] "PROSITE"      "REFSEQ"       "SYMBOL"       "UCSCKG"      
[25] "UNIGENE"      "UNIPROT"
```{r message=FALSE}
library("org.Mm.eg.db")
```

```{r message=FALSE}
#gage has kegg and go in it
library(pathview)
library(gage)
library(gageData)

#data(kegg.sets.hs)
#data(sigmet.idx.hs)
```

```{r}
# Notes from bggn213 c15 that may be useful to you:
#Focus on signaling and metabolic pathways only
#what is this
#kegg.sets.hs = kegg.sets.hs[sigmet.idx.hs]
# Examine the first 3 pathways.
#head(kegg.sets.hs, 3)
```




###Practicing dplyr verbs on sample data:

Sample data includes just two columns: An "ID" column with 12 unique random alpha-numeric assigments and a description column correlating to these IDs which frequently contain the word "gene", "sup", and/or "thing" to practice creating groups based on words contained in gene names.
```{r}
dprac<-read.csv("Dplyrpractice.csv")
dpract<-as.tbl(dprac)
```



The following 2 chunks are not to be used, but good for you to know that you tried. The first code chunk is limited to 1 & 0 values and single columns per call of function. Would require the same number of calls as categories desired **PLUS** an additional step of summing and accounting for any possible duplicate assigments. Named this function grepscore1 for version 1 of a possible scoring function based on using grep. The second chunk generates index (positional info) of TRUE grepl outcomes but how you would create values in a new column for only 3 rows is unclear and maybe not possible.
```{r message=FALSE}
grepscore1<- function(z, x) {
  mutate(z, GrepScore.y = as.numeric(grepl(x, z$Description)))}
grepscore1(dpract, "ge")
```
```{r message=FALSE}
ginds<-which(grepl("sup", dpract$Description))
ginds
```


Let's improve this code by **nesting ifelse() into mutate()**. 
Online example about classroom letter grades where "gradebook"" was the df and "letter"" was the column to-be-added using the mutate function, as defined by info in the "grade" column used the following code to do something similar to my aim:
mutate(gradebook, letter = ifelse(grade %in% 60:69, "D",
                                     ifelse(grade %in% 70:79, "C",
                                            ifelse(grade %in% 80:89, "B",
                                                   ifelse(grade %in% 90:99, "A", "F")))))
                                                   
```{r Functional Practice Code, message=TRUE}
#This uses dataframe as your only argument, z
#Note the inclusion of an OR operator inside tge second grepl call to classify multiple things as 1 subtype
grepcatp<- function(z) {
  mutate(z, ProtCat = ifelse(grepl("sup|thing", z$Description), "Super", 
                               ifelse(grepl("ge|eni", z$Description), "Genesies", "No Class")))}

```
Note that when you call this function on your practice dataset that the observation "thinggene" gets classified by the first category it falls into, not the second. The first category (Super) is assigned based on the word "thing" being present in the description column, and the second category you created (Genesies) is based on "gene" being there. Since "thinggene" contains both, it is **important to note** which category it was ultimately assigned.
```{r message=TRUE}
dpract.cat<-grepcatp(dpract)
dpract.cat
```

```{r message=FALSE}
dpract$Description<-gsub("g.*","", dpract$Description)
```
```{r message=FALSE}
dpract
```


```{r}
#library(tidyr)
#strsplit
#dpract%>%separate()
```









## Data Analysis


One of the first thing you may want to do is add your classification column, as practced above. There is an annotation dbs that can do an ~equivalent form of this for you, but your own simplification of perhaps a smaller number of categories may be preferred?
Add column for protein category named "ProtCat" using **mutate()** to classify proteins based on the content of their $DESCRIPTION, a column from IP2 that includes both the protein name and gene symbol. 


Notes:
-This you should use on your data but watch out upper/lower case letters for your grep... Right now you have omitted the first letter of several words in order to capture them when they occur with lower case first letter and upper case first letter.  May want to return to this and learn how to call both.

-Input to the function grepcat is simply your dataframe. (which is read in as **MSData**)

-Write in compartmental designations (ifelse statements) toward the **beginning** of the code because you want them to supercede other categories like "tf" or "kinase" if they are compartment specific. You have not addressed the potential for dual classification in your code directly, although all manual pre-screening of excel workbook looked good.
(if you use "actin" it will pick up that sequence of letters in "interacting")


Start by getting your data:
```{r}
MSData<-as.tbl(read.csv("0302WT2.csv"))
```
Have a look:
```{r}
head(MSData)
colnames(MSData)
```

Clean up data:
Overwrite variable MSData after removing extra stuff from strings in the Description column.

Overwrite column:
```{r}
MSData$DESCRIPTION<-gsub("PE=.*","", MSData$DESCRIPTION)
```



```{r grepcat() function - Make Protein Category Column}
grepcat<- function(z) {
  mutate(z, ProtCat = ifelse(grepl("itochondria|ubiquinone|ytochrome", z$DESCRIPTION), "Mitochondria", 
                               ifelse(grepl("kinase|phosphatase" , z$DESCRIPTION), "Kinase/Phosphatase",
                                      ifelse(grepl("istone-lysine N|istone deacetylase|istone demethy|istone-binding protein|istone methyl", z$DESCRIPTION), "Histone Modifiers",
                                             ifelse(grepl("ibonucleoprot", z$DESCRIPTION), "Ribonucleoproteins",
                                                    ifelse(grepl("T-complex|Heat shock", z$DESCRIPTION), "Chaperone complexes",
                                                           ifelse(grepl("40S ribosomal prot|60S ribosomal prot", z$DESCRIPTION), "Ribosome",
                                                                  ifelse(grepl("olgi|esicle|xosome|endoplasmic", z$DESCRIPTION), "ER-Golgi-Vesicular-Exosome",
                                                                        ifelse(grepl("inc finger|PHD finger|orkhead box|PDZ and|nhibitor of growth protein", z$DESCRIPTION), "Transcription Factor",
                                                                               ifelse(grepl("rueppel-like factor|obox|B-cell CLL|our and a half LIM", z$DESCRIPTION), "Transcription Factor",
                                                                                      ifelse(grepl("RNA polymerase II|ranscription initiation|ranscription elongation|General transcription factor", z$DESCRIPTION), "General Transcription",
                                                                                             ifelse(grepl("Histone", z$DESCRIPTION), "Histones",
                                                                                                      ifelse(grepl("portin|uclear pore|ucleoporin", z$DESCRIPTION), "Nuclear Transport Machinery",
                                                                                                             ifelse(grepl("plicing factor|RNA helicase|mRNA-processing|THO complex", z$DESCRIPTION), "mRNA processing",
                                                                                                                    ifelse(grepl("biquitin|SUMO", z$DESCRIPTION), "Ub-SUMO-related",
                                                                                                                           ifelse(grepl("actinin|Actin-|Actin,|ubulin|yosin|oronin|ollagen|ransgelin|Septin-|dynein|ytoskeleton", z$DESCRIPTION), "Cytoskeleton",
                                                                                                                                  ifelse(grepl("ukaryotic translation initiation|RNA-binding protein|RNA binding protein", z$DESCRIPTION), "Translation Regulation",
                               ifelse(grepl("ranscription factor", z$DESCRIPTION), "Transcription Factor",
                                      "Other"))))))))))))))))))}
```


Apply classification function **grepcat()** to your data:
```{r}
MSData.cat<-grepcat(MSData)
```
Verify your new column "ProtCat" is there:
```{r}
colnames(MSData.cat)
```

There are `r length(unique(MSData.cat$ProtCat))` categories:
```{r}
print(unique(MSData.cat$ProtCat))
```

```{r}
glimpse(MSData.cat)
```




If you have to get rid of any NA values, you will use:
```{r}
#if you have to get rid of NA values... area ratio perhaps
#filter(MSdata.cat, !is.na(AREA_RATIO) 
     
```



###make small lists of potentially interesting transcription factors.
Of the proteins qualified as "Transcription Factor" in your new protein category column, **filter()** those that have a good Area Ratio and Spec count.
```{r}
allTF<-unique(filter(MSData.cat, ProtCat=="Transcription Factor"))
nrow(allTF)
```


```{r}
#Interesting Transcription Factors, Shuttle Out(SO)
IntTF.SO<-MSData.cat%>%filter(ProtCat=="Transcription Factor" & AREA_RATIO >= 1.5 & SPEC_COUNT>1) 
#IntTF.SO$DESCRIPTION or maybe better:
unique(IntTF.SO$DESCRIPTION)
#where AREA_RATIO CUTOFF is not hard-coded as 1.5 or anything,>>> rather is a calculation of some cut-off value (top 25% of shuttling values in data?) !!!!

```

```{r}
#Shuttle In (SI)
IntTF.SI<-MSData.cat%>%filter(ProtCat=="Transcription Factor" & AREA_RATIO <= 0.5 & SPEC_COUNT>1) 
#IntTF.SI$DESCRIPTION or maybe better:
unique(IntTF.SI$DESCRIPTION)
```

### TF quick summary:
There are **`r nrow(unique(IntTF.SO))`** Transcription Factors that potentially shuttle out of the nucleus.
There are **`r nrow(unique(IntTF.SI))`** Transcription Factors that potentially shuttle into the nucleus.






###Annotating Data
To annotate my data. I will want to map into the annotation database for several different protein lists that I generate leading up to this point including:
1. The whole data 
2. The lists of shuttling proteins
3. The refined lists of shuttling proteins (nice intensity and >1 spec count?) or potentially the refined list of potentially interesting TFs from code chunk above.
4. The list of non-shuttling proteins (I will want this to include histones and ? what else do I expect not to shuttle)

```{r} 
#NOTE I HAVE "my.df.intheformat.ofmymaking" as a placeholder for the name of your dataframe which you will build up to this code chunk. Once you have built up to this and named your df properly, fix the name in this code chunk and DELETE this text.
#You will be using the Uniprot ID for mapping to annotation databases because this is the first column of your data. 
#keys = will have the be either my.df.intheformat.ofmymaking$UniprotIDs if you have literally named a column "UniprotIDs" --- but if the Uniprot IDs in your data are the row names of your dataframe then you can 


#my.df.intheformat.ofmymaking$symbol <- mapIds(org.Mm.eg.db,
                    # keys=row.names(my.df.intheformat.ofmymaking),
                    # column="SYMBOL",
                    # keytype="UNIPROT",
                    # multiVals="first")
```

